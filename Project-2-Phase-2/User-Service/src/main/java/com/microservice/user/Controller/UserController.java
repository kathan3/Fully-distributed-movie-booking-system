package com.microservice.user.Controller;

import com.microservice.user.Models.UserDB;
import com.microservice.user.Repository.UserDBRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.transaction.annotation.Isolation;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.client.RestTemplate;
import java.util.List;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;


@RestController
@Transactional(isolation= Isolation.SERIALIZABLE)
public class UserController {
    @Autowired
    private UserDBRepository userRepository;

    @Autowired
    private RestTemplate restTemplate;

    private Lock lock = new ReentrantLock();
    private Lock sublock=new ReentrantLock();

    @GetMapping("/users/{user_id}")
    public ResponseEntity<UserDB> findUser(@PathVariable("user_id") Integer id){
        lock.lock();
        try{
            UserDB user= userRepository.findById(id);
            if(user!=null) { // Check if the user exists
                // Return the details of the user with ID user_id with HTTP status code 200 (OK)
                return new ResponseEntity<>(user, HttpStatus.OK);
            }
            // If the user doesn’t exist, return HTTP 404 (Not Found)
            else return new ResponseEntity<>(new UserDB(), HttpStatus.NOT_FOUND);
        }
        finally {
            lock.unlock();
        }

    }

    @PostMapping(value = "/users",consumes = "application/json")
    public ResponseEntity<UserDB> addUser(@RequestBody UserDB user){
        lock.lock();
        try{
            String email=user.getEmail();
            if(userRepository.findByEmail(email)==null) { // Check if user with same email already exists
                // Create a new user with the given name and email and an autogenerated id
                UserDB new_user=userRepository.save(user);
                // Return user details along with HTTP status code 201 (Created)
                return new ResponseEntity<>(new_user,HttpStatus.CREATED);
            }
            // If a user with the given email address already exists then return HTTP status code 400 (Bad Request)
            else return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
        }
        finally {
            lock.unlock();
        }

    }

    @Transactional
    @DeleteMapping(value = "/users/{user_id}")
    public ResponseEntity<UserDB> deleteUser(@PathVariable("user_id") Integer id){
        sublock.lock();
        try{
            if(userRepository.findById(id)!=null){ // Check if the user exists
                try{ // If the user has made any bookings, delete them
                    restTemplate.delete("http://host.docker.internal:8081/bookings/users/"+id);
                }
                catch(Exception e){}
                try{ // If the user has a wallet, delete it
                    restTemplate.delete("http://host.docker.internal:8082/wallets/"+id);
                }
                catch(Exception e){}
                // Delete the user
                userRepository.deleteById(id);
                // Return HTTP 200 (OK) status code
                return new ResponseEntity<>(HttpStatus.OK);
            }
            else
                // If the user doesn’t exist, return HTTP 404 (Not Found)
                return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        }
        finally {
            sublock.unlock();
        }

    }

    @Transactional
    @DeleteMapping(value = "/users")
    public ResponseEntity<UserDB> deleteAllUsers(){
        lock.lock();
        try{
            // Fetch all the users
            List<UserDB> userDBs = userRepository.findAll();
            for(int i = 0; i < userDBs.size(); i++)
                // For each user, call the DELETE /users/{user_id} endpoint of the User service
                restTemplate.delete("http://host.docker.internal:8080/users/"+userDBs.get(i).getId());
            // Return HTTP 200 (OK) status code
            return new ResponseEntity<>(HttpStatus.OK);
        }
        finally {
            lock.unlock();
        }

    }
}

